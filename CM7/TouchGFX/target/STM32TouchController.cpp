/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : STM32TouchController.cpp
  ******************************************************************************
  * This file is generated by TouchGFX Generator 4.19.1.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2022 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* USER CODE BEGIN STM32TouchController */

#include <STM32TouchController.hpp>
#include "main.h"

extern "C" I2C_HandleTypeDef hi2c4;

static volatile bool controllerIsGT911 = false;
volatile bool doSampleTouch = false;
GPIO_PinState isTouched = GPIO_PIN_RESET;

extern "C"
{
    void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
    {
        if (GPIO_Pin == TP_IRQ_Pin)
        {
            /* Communication with TS is done via I2C.
            Often the sw requires ISRs (interrupt service routines) to be quick while communication
            with I2C can be considered relatively long (depending on SW requirements).
            Considering that the TS feature don't need immediate reaction,
            it is suggested to use polling mode instead of EXTI mode,
            in order to avoid blocking I2C communication on interrupt service routines */

            /* Here an example of implementation is proposed which is a mix between pooling and exit mode:
            On ISR a flag is set (exti5_received), the main loop polls on the flag rather then polling the TS;
            Mcu communicates with TS only when the flag has been set by ISR. This is just an example:
            the users should choose they strategy depending on their application needs.*/

            doSampleTouch = true;
            return;
        }
    }
}

void STM32TouchController::init()
{
    const uint16_t GT911_CHIP_ID_REG = 0x8140;
    uint8_t buf[4];
    HAL_I2C_Mem_Read(&hi2c4, 0xBA, GT911_CHIP_ID_REG, 2, buf, 4, HAL_MAX_DELAY);

    if (buf[0] == '9' && buf[1] == '1' && buf[2] == '1' && buf[3] == 0)
    {
        controllerIsGT911 = true;
    }
}

bool STM32TouchController::sampleTouch(int32_t& x, int32_t& y)
{
    uint8_t touches = 0;
    uint8_t buf[4];
    const uint16_t STATUS_REG = 0x814E;
    const uint16_t TOUCH_POS_REG = 0x8150;
    const uint8_t FT5336_TD_STAT_REG = 0x02;
    const uint8_t FT5336_P1_XH_REG = 0x03;
    uint8_t ZERO = 0;
    if (doSampleTouch)
    {
        if (controllerIsGT911)
        {
            HAL_I2C_Mem_Read(&hi2c4, 0xBA, STATUS_REG, 2, buf, 1, HAL_MAX_DELAY);
            touches = (0x0F & buf[0]);

            HAL_I2C_Mem_Write(&hi2c4, 0xBA, STATUS_REG, 2, &ZERO, 1, HAL_MAX_DELAY);

            if (touches > 0)
            {
                HAL_I2C_Mem_Read(&hi2c4, 0xBA, TOUCH_POS_REG, 2, buf, 4, HAL_MAX_DELAY);
                x = buf[0] + (buf[1] << 8);
                y = buf[2] + (buf[3] << 8);
            }
        }
        else // FT3336
        {
            HAL_I2C_Mem_Read(&hi2c4, 0x70, FT5336_TD_STAT_REG, 1, buf, 1, HAL_MAX_DELAY);
            touches = (0x0F & buf[0]);

            if (touches > 0)
            {
                HAL_I2C_Mem_Read(&hi2c4, 0x70, FT5336_P1_XH_REG, 1, buf, 4, HAL_MAX_DELAY);
                x = ((buf[2] & 0x0F) << 8) + buf[3];
                y = ((buf[0] & 0x0F) << 8) + buf[1];
            }
        }
        doSampleTouch = false;
    }
    return (touches > 0);
}

/* USER CODE END STM32TouchController */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
